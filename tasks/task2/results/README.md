# Стратегия миграции данных (Data Migration Strategy) и To-Be архитектура

## 1. Трансформация алгоритма работы приложения
В рамках выделения микросервиса бронирований реализован паттерн **Strangler Fig**. Монолит продолжает принимать входящие клиентские запросы (`POST /api/bookings` и `GET /api/bookings`), но его внутренняя база данных (`hotelio`) больше не используется для бронирований. Вместо этого монолит транслирует вызовы в новый выделенный микросервис (`booking-service`) через протокол gRPC. 

Новый микросервис самостоятельно работает со своей независимой базой данных `booking_db`, а также асинхронно публикует события `BookingCreated` в Apache Kafka, которые вычитываются сервисом `booking-history-service` для накопления статистики в базу `history_db`.

## 2. Проблема текущего состояния
Поскольку новые записи теперь направляются в новую базу данных `booking_db`, а старые данные остались лежать в таблице `booking` базы данных `hotelio`, образовался разрыв. 
Функция чтения (`GET /api/bookings`) в данный момент запрашивает данные из новой `booking_db` (по gRPC). Таким образом клиент не может получить доступ к истории бронирований, которые были созданы до разделения системы на микросервисы.

## 3. Целевая To-Be архитектура и шаги миграции
Для полного и безопасного перехода на новую архитектуру необходимо выполнить следующие шаги:

1. **Разовая синхронизация данных (Data Migration Script/Job):** 
   Необходимо написать разовый скрипт миграции (ETL-скрипт), который прочтет все существующие исторические записи из таблицы `booking` базы `hotelio` и аккуратно вставит их в таблицу `booking` базы `booking_db`. Данный перенос должен быть выполнен в момент окна обслуживания или Maintenance, когда создание новых бронирований будет временно приостановлено.

2. **Перевод клиентского трафика напрямую на микросервис (Cut-over phase):**
   У `booking-service` предусмотрен и будет расширен собственный REST API контроллер. На уровне API Gateway или Nginx Ingress необходимо перенастроить маршруты так, чтобы любые HTTP-запросы на эндпоинты `/api/bookings` направлялись сразу в `booking-service`, минуя сам монолит `hotelio-monolith`.

3. **Очистка Legacy-кода (Tech Debt Cleanup):**
   - Удаление старой сущности базы данных `@Entity Booking` из кодовой базы монолита.
   - Удаление старого `BookingController` и `GrpcBookingService` из монолита, так как монолит больше не будет выполнять функции HTTP-to-gRPC прокси.
   - Удаление (DROP) таблицы `booking` в исходной монолитной базе `hotelio`.

Данный план гарантирует консистентность старых и новых данных для конечного пользователя и позволит окончательно распилить монолит.
